# Chapter 2：Wikidata 数据模型详解（Q/P/声明/限定符/引用）

## 1. 开篇：为什么造对话数据要懂“超图”模型？

在传统的知识图谱（KG）教程中，你可能学过“三元组（Subject-Predicate-Object）”。例如：`（李白，出生地，碎叶城）`。

但在构建**真实对话**数据时，三元组是远远不够的。人类的对话充满了**上下文（Context）**、**时效性（Temporality）**和**来源（Provenance）**。请看下面这个对话示例：

> **用户**：奥巴马是美国总统吗？
> **Bot（三元组思维）**：是。（这就是他的属性）
> **Bot（Wikidata 思维）**：他**曾是**美国总统。他于 **2009年** 就职，**2017年** 卸任，是第 **44** 任总统。

为了生成第二个回答，你需要的数据结构不是简单的连线，而是一个“声明（Statement）”结构。Wikidata 本质上是一个**超图（Hypergraph）**——一条边上可以挂载更多的键值对。

**本章目标**：
1.  彻底搞懂 **QID** (实体) 和 **PID** (属性) 的指纹机制。
2.  掌握 **Statement (声明)** 的完整解剖结构：Main Snak, Qualifiers, References, Ranks。
3.  学习处理复杂数据类型（时间精度、带单位的数量、多语言文本）。
4.  学会将这些结构映射为 JSON 对话数据模版。

---

## 2. 基础原子：指纹 (Fingerprint)

在 Wikidata 中，每个页面（无论是实体还是属性）都有三个核心的语言描述字段，统称为“指纹”。这三者对于**自然语言生成（NLG）**和**自然语言理解（NLU）**有着完全不同的用途。

### 2.1 实体 (Item, Q-ID) 与 属性 (Property, P-ID)
*   **Item (Qxxxx)**：代表节点。如 `Q2` (地球), `Q42` (道格拉斯·亚当斯)。
*   **Property (Pxxx)**：代表边，但它是特殊的边，它定义了关系的语义。如 `P31` (是...的实例), `P569` (出生日期)。

### 2.2 标签、描述与别名：对话生成的“语料库”

很多开发者只抓取 Label，这是错误的。在造对话数据时，请遵循以下 **Rule-of-Thumb**：

| 字段 | 英文 | 示例 (Q957 / 北京) | 对话生成中的角色 | 策略 |
| :--- | :--- | :--- | :--- | :--- |
| **标签** | **Label** | 北京 | **Bot 的嘴** (NLG) | Bot 输出时使用的标准名称，确保回答专业规范。 |
| **描述** | **Description** | 中华人民共和国首都 | **消歧义** (Disambiguation) | 当用户问“凤凰”时，用于区分是“神话生物”、“古城”还是“自行车品牌”。 |
| **别名** | **Aliases** | 北平<br>燕京<br>Beijing | **用户的嘴** (NLU/Diversity) | **这是宝藏！** 用来模拟多样化的用户提问。用户可能问“燕京在哪？”，而不是“北京在哪？”。 |

> **ASCII 图解：指纹结构**
> ```text
> [Item: Q957]
>   |
>   +-- Labels:
>   |    |-- zh: "北京"
>   |    |-- en: "Beijing"
>   |
>   +-- Descriptions:
>   |    |-- zh: "中华人民共和国首都"
>   |
>   +-- Aliases:
>        |-- zh: ["北平", "燕京", "京城", "帝都"(可能包含俗语)]
> ```

---

## 3. 核心架构：声明 (Statement) 的完整解剖

这是本章的重点。不要把 Wikidata 的数据看作 `Key: Value`，要看作一组**声明对象**。

### 3.1 结构图解

以 **“玛丽·居里 (Q7186) 获得 诺贝尔物理学奖 (Q38104)”** 为例：

```text
[实体 Item: Q7186 (玛丽·居里)]
   |
   +-- [属性 Property: P166 (获奖)]
         |
         +-- [声明 Statement Node]
               |
               |-- 1. [Main Snak (核心值)]
               |       ╰-> Value: Q38104 (诺贝尔物理学奖)
               |
               |-- 2. [Qualifiers (限定符)]  <-- 让对话变丰富的关键
               |       |-- P585 (时间点): 1903年
               |       |-- P1706 (一起获奖者): 皮埃尔·居里 (Q37463)
               |       ╰-- P1706 (一起获奖者): 亨利·贝克勒 (Q41269)
               |
               |-- 3. [References (引用)]    <-- 让对话可信的关键
               |       ╰-- [Reference Block]
               |             |-- P854 (参考URL): http://nobelprize.org/...
               |             ╰-- P813 (检索日期): 2020-01-01
               |
               ╰-- 4. [Rank (等级)]: Preferred (首选)
```

### 3.2 组件详解与对话应用

#### 1. Main Snak (核心值)
这是事实的主干。
*   **应用**：回答 `What` 类问题。
*   **例子**：“玛丽·居里得过什么奖？” -> “诺贝尔物理学奖”。

#### 2. Qualifiers (限定符)
这是附着在主干上的修饰词。**没有限定符，多轮对话就无法展开。**
*   **应用**：回答 `When`, `Who else`, `Why`, `How` 类问题，或者用于**主动追问**。
*   **对话合成策略**：
    *   *User*: 玛丽·居里得过诺贝尔奖吗？
    *   *Bot*: 得过。（基于 Main Snak）
    *   *Bot (进阶)*: 是的，她在 **1903年**（基于 P585）和丈夫 **皮埃尔·居里**（基于 P1706）一起获得了诺贝尔物理学奖。

#### 3. References (引用)
数据的来源证据。
*   **应用**：用于生成 `Source` 字段，或在 Bot 回答受质疑时抛出证据。
*   **注意**：不是所有声明都有引用，采样时可以优先过滤出 `aggregated by (P248)` 或 `reference URL (P854)` 存在的声明。

#### 4. Rank (等级)
一个属性可能有多个值，Rank 告诉我们哪个更重要。
*   **Preferred (首选)**：当前的、最公认的、官方的。
    *   *例*：现任法国总统。
*   **Normal (正常)**：历史上的、其他的、并列的。
    *   *例*：前任法国总统。
*   **Deprecated (废弃)**：错误的或过时被修正的（但为了记录历史保留）。
    *   *例*：冥王星曾被归类为行星（如果在 Wikidata 中保留此记录，可能会标记为 Deprecated 或通过 Qualifier 标记结束时间）。

> **常见陷阱**：在生成“现在的 X 是谁？”这类对话时，必须过滤 `Rank != Deprecated`，且通常优先取 `Preferred`，或者检查 `End Time` 限定符是否存在。

---

## 4. 关键数据类型 (Data Types)

在 JSON 响应中，值（Value）的格式随类型变化。解析错误是新手最常遇到的 Bug。

### 4.1 WikibaseItem (实体链接)
*   **JSON 表现**：`{"entity-type": "item", "id": "Qxxx"}`
*   **处理**：你需要拿着这个 ID 再去查一次它的 Label，才能在对话中说出来。

### 4.2 Time (时间)
*   **JSON 表现**：`{"time": "+1903-00-00T00:00:00Z", "precision": 9, ...}`
*   **关键字段：Precision (精度)**
    *   `11` = 天 (Day) -> 可生成 "X年X月X日"
    *   `10` = 月 (Month) -> 可生成 "X年X月"
    *   `9` = 年 (Year) -> **只能**生成 "X年"。千万不要因为看到 `00-00` 就生成 "1月1日"。
    *   `7` = 世纪 (Century) -> 生成 "X世纪"。

### 4.3 Quantity (数量)
*   **JSON 表现**：`{"amount": "+8848", "unit": "http://.../Q11573"}`
*   **处理**：
    1.  **Unit**：单位是指向实体的 URI（如 `Q11573` 代表米）。必须解析这个 ID 对应的中文 Label。
    2.  **Amount**：通常是字符串形式的数字，解析时注意正负号。
    3.  **Bounds**：有时包含 `upperBound` 和 `lowerBound`，表示误差范围。对话中可以说“大约 8848 米”。

### 4.4 Monolingual Text (单语文本)
*   有些属性（如 P1448 官方名称）特定于某种语言。
*   处理：检查 `language` 字段。如果你的对话是中文的，但文本是法文，需要决策是直接显示原文，还是尝试寻找翻译。

---

## 5. 特殊值：SomeValue 与 NoValue

Wikidata 允许声明“不知道”或“没有”。

*   **SomeValue (某值/未知值)**：
    *   含义：我知道有这个关系，但我不知道具体是谁/是什么。
    *   *例子*：某古人的父亲是存在的，但史书没记载名字。
    *   *SPARQL 表现*：节点是一个空白节点 (Blank Node)。
    *   *对话生成*：Bot 应回答“资料记载不详”或“具体身份未确认”。

*   **NoValue (无值)**：
    *   含义：确定没有这个关系。
    *   *例子*：某人终身未婚，其配偶属性可能被标记为 NoValue。
    *   *对话生成*：Bot 应回答“没有”、“无”。

---

## 6. 本章小结

1.  **不仅仅是三元组**：Wikidata 是以**声明 (Statement)** 为中心的。
2.  **限定符 (Qualifier) 是对话的灵魂**：它提供了时间、地点、原因和伴随状况，是构造多轮对话追问逻辑的基础。
3.  **别名 (Alias) 是扩充语料的神器**：利用别名生成多样化的 User Query。
4.  **精度与单位**：处理时间时看 `precision`，处理数量时必查 `unit`。
5.  **Rank 决定时效性**：区分“现任”与“前任”，靠的是 Rank 和时间限定符。

---

## 7. 练习题

### 基础题

**练习 2.1：手动解析 JSON**
访问 [Wikidata API (Q42)](https://www.wikidata.org/wiki/Special:EntityData/Q42.json)。
搜索 `P569` (出生日期)。
1.  找到它的 `mainsnak` -> `datavalue` -> `value`。
2.  记录下 `time` 字符串和 `precision` 数值。
3.  如果 precision 是 11，你应该转换成什么中文格式？如果是 9 呢？

<details>
<summary>点击展开答案提示</summary>

*   **URL**: 打开链接后搜索 "P569"。
*   **结构**: 你会看到 `time: "+1952-03-11T00:00:00Z"`, `precision: 11`。
*   **转换**:
    *   Precision 11 (Day) -> "1952年3月11日"
    *   Precision 9 (Year) -> "1952年" (忽略后面的月日)
</details>

**练习 2.2：寻找限定符**
在 Wikidata 页面查看 **泰坦尼克号 (Q25173)** 的属性 **长眠地 (P119)**。
1.  它的值是“北大西洋”。
2.  它有一个非常关键的限定符 **坐标 (P625)**。
3.  如果没有这个限定符，导航员能找到它吗？思考这在 "Ask for location" 对话中的区别。

<details>
<summary>点击展开答案提示</summary>

*   **观察**: P119 的值是广义的 "North Atlantic Ocean"，但下方限定符 P625 给出了精确的经纬度。
*   **对话区别**:
    *   简单回答: "它沉没在北大西洋。"
    *   精确回答: "它位于北大西洋，具体坐标是北纬 41度43分，西经 49度56分。"（通过读取限定符实现）
</details>

**练习 2.3：别名的提取**
选择一个你喜欢的电子游戏或电影（例如《原神》 Q65059474 或 《黑客帝国》 Q83495）。
查看其所有中文和英文别名。
设计 3 个不同的用户提问，分别使用 Label 和不同的 Alias。

<details>
<summary>点击展开答案提示</summary>

*   **实体**: Q65059474 (原神)
*   **Label**: 原神
*   **Alias**: Genshin Impact, Yuan Shen
*   **生成的提问**:
    1.  "**原神**是哪一年发行的？" (Label)
    2.  "我想知道 **Genshin Impact** 的开发商是谁？" (Alias En)
    3.  "这游戏也叫 **Yuan Shen** 吗？" (Alias Pinyin)
</details>

---

### 挑战题

**练习 2.4：多值与 Rank 的处理逻辑**
实体：**中华人民共和国 (Q148)**。
属性：**国家元首 (P35)**。
这个属性下列出了从毛泽东到现任的所有主席。
1.  找到标记为 `Preferred` 的声明。它是谁？
2.  找到其他的声明。它们的 Rank 是什么？
3.  设计一段伪代码逻辑：当用户问“中国国家元首是谁？”时，如何从这堆列表中只返回正确的那一个？

<details>
<summary>点击展开答案提示</summary>

1.  **Preferred**: 习近平 (Q15031)
2.  **Normal**: 毛泽东、刘少奇等历史主席。
3.  **伪代码**:
    ```python
    statements = get_statements(entity="Q148", property="P35")
    # 策略1: 优先找 Preferred
    answer = find(statements, rank="preferred")
    if not answer:
        # 策略2: 如果没有 preferred，找 end_time 不存在的 (假设现在还在任)
        answer = find(statements, qualifier_p582=None)
    print(f"现任元首是: {get_label(answer.value)}")
    ```
</details>

**练习 2.5：基于限定符的“澄清式”对话**
场景：用户问“乔布斯什么时候离开苹果的？”
实体：**史蒂夫·乔布斯 (Q19837)**，属性：**雇主 (P108)** -> 值：**苹果公司**。
观察：你会发现这里有**两个**针对苹果公司的声明（因为他离开过又回来了）。
任务：利用 `P580` (开始时间) 和 `P582` (结束时间) 限定符，构造一个能理清这段历史的 Bot 回答。

<details>
<summary>点击展开答案提示</summary>

*   **数据**:
    *   声明1: Apple, Start: 1976, End: 1985
    *   声明2: Apple, Start: 1997, End: 2011
*   **构造回答**:
    *   "乔布斯曾**两次**任职于苹果公司。第一次是从 **1976年** 到 **1985年**；第二次是从 **1997年** 回归，直到 **2011年**。"
*   *提示*: 检测到同一属性指向同一 Value 但有不同的限定符时，是生成“对比/变迁类”对话的绝佳机会。
</details>

---

## 8. 常见陷阱与错误 (Gotchas)

1.  **单位对应的不是中文**：
    *   *现象*：生成“这座山高 8848 **Q11573**”。
    *   *原因*：获取 Quantity 类型时，直接使用了 unit 的 URL 后缀。
    *   *解决*：必须像处理普通 Entity 一样，去获取 `Q11573` 的 Label（即“米”）。

2.  **默认公历的坑**：
    *   *现象*：获取古代人物生日，日期偏差几天。
    *   *原因*：Wikidata 的时间模型存储了历法（格里历 vs 儒略历）。
    *   *解决*：对于一般对话数据，通常忽略历法转换，直接取字符串中的年月日即可。但如果是严谨的历史对话，需注意 `calendarmodel` 字段。

3.  **忽略“废弃”等级**：
    *   *现象*：Bot 说“冥王星是太阳系第九大行星”。
    *   *原因*：没有过滤 `rank != deprecated`。
    *   *解决*：在 SPARQL 查询或后处理中显式排除 Deprecated 声明，除非你的目的是做“历史上的错误认知”科普。

4.  **把 Qualifiers 当作 Main Value**：
    *   *现象*：查询“谁获得了诺贝尔奖？”，结果列表里不仅有获奖人，还混入了一些莫名其妙的日期或地点。
    *   *原因*：SPARQL 写得不对，混淆了 `wdt:Pxxx` (Truth) 和 `pq:Pxxx` (Qualifier)。我们将在下一章详细讲解如何正确查询它们。

---
[< Chapter 1](chapter1.md) | [Return to Index](index.md) | [Chapter 3 >](chapter3.md)
